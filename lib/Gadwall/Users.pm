package Gadwall::Users;

use Mojo::Base 'Gadwall::Table';

use Gadwall::Util qw(bcrypt mail);

sub columns {
    my $self = shift;
    return (
        login => {},
        email => {
            required => 1,
        },
        password => {
            fields => [qw/pass1 pass2/],
            required => 1,
            validate => sub {
                my (%p) = @_;
                return unless $p{pass1};
                return unless $p{pass1} eq $p{pass2};
                return (password => bcrypt($p{pass1}));
            },
            error => "Please enter the same password twice"
        },
        roles => {
            fields => qr/^is_[a-z]+$/,
            validate => sub {
                my (%set) = @_;

                my $i = 30;
                my @roles = (0)x31;
                my $class = $self->class_name($self->rowclass);
                foreach my $r ($class->role_names()) {
                    if ($set{"is_$r"}) {
                        $roles[$i] = 1;
                    }
                    $i--;
                }

                return (roles => join "", @roles);
            }
        }
    );
}

sub extra_columns { qw(roles::int) }

# Takes the current password and (two copies of) a new password and
# changes the user's password. Expects the router to set user_id in
# the stash. Users should have access to only their own password.
#
# $auth->route('/users/:user_id/password')->to('users#password');

sub password {
    my $self = shift;

    my $u = $self->stash('user');
    my $id = $self->stash($self->primary_key);
    my $passwd = $self->param('password');

    unless (($u->has_role("admin") && $u->{user_id} != $id) ||
            ($passwd && $u->has_password($passwd)))
    {
        return $self->json_error("Incorrect password");
    }

    my %set = $self->_validate(
        { $self->columns }, {
            pass1 => $self->param('pass1'),
            pass2 => $self->param('pass2')
        }
    );

    unless (%set && $self->_update($id, %set)) {
        return $self->json_error;
    }

    $self->app->log->info(
        "Password changed by $u->{email}".
        $u->{user_id} ne $id ? " (for user $id)" : ""
    );
    return $self->json_ok("Password changed");
}

# This action takes an email address and, if it belongs to a user, sends
# them a "reset password" link by email. It should be available via POST
# to everyone.
#
# $r->route('/forgot-password')->via('post')->to('users#send_password_reset')

sub send_password_reset {
    my $self = shift;

    my $user = $self->select_one(
        "select * from users where email=?", $self->param("email")
    );

    if ($user) {
        my $uid = $user->{user_id};
        my $url = $self->new_controller('Confirm')->generate_url(
            "/reset-password", $uid
        );

        if ($url) {
            my $from = $self->stash('config')->{"owner-email"};
            my $host = $self->canonical_url->host;
            my $to = $user->{email};
            mail(
                from => $from, to => $to,
                subject => "Reset your password at $host",
                text => $self->render_partial(
                    template => "users/password-reset", format => 'txt',
                    from => $from, to => $to, host => $host, url => $url,
                    template_class => __PACKAGE__,
                )
            );
        }

        $self->app->log->info(
            "Sent password reset link to $user->{email}"
        );
    }

    # We always claim to have sent the reset link, because we don't want
    # to leak any information about valid email addresses. It's true for
    # valid users, and we don't care about anyone else.

    $self->render(
        text => "A link to reset your password has been sent to your email address"
    );
}

# This action handles people clicking on their password reset links. It
# first displays a password reset form and then accepts its submission.
# It should be made available by GET and POST through a confirm#by_url
# bridge (which ensures that the link was generated by us). It expects
# the bridge to set user_id in the stash.

sub reset_password {
    my $self = shift;

    my $uid = $self->stash('user_id');
    my %set;

    if ($self->req->method eq 'POST') {
        %set = $self->_validate(
            { $self->columns }, {
                pass1 => $self->param("pass1"),
                pass2 => $self->param("pass2")
            }
        );
        if (%set) {
            $self->_update($uid, %set);
        }
    }

    unless (%set && $self->_update($uid, %set)) {
        my %params;
        unless (%set) {
            # Unless there's a database error, keep regenerating the
            # token to allow the user one more access to this URL.
            my $url = $self->new_controller('Confirm')->generate_url(
                "/reset-password", $uid
            );
            $params{t} = $url->query->param('t') if $url;
        }
        $self->render(
            template => "users/reset-password",
            template_class => __PACKAGE__,
            %params
        );
        return;
    }

    $self->render_plaintext("Password reset");

    my $user = $self->select_by_key($uid);
    $self->app->log->info(
        "Password reset by $user->{email}"
    );
}

1;

__DATA__

@@ users/password-reset.txt.ep
To reset your password at <%= $host %>, visit:

<%= $url %>

This link is valid for one hour.

--
Administrator
<%= $from %>

@@ users/reset-password.html.ep
% layout 'default';
<%= post_form reset_password => begin %>
Enter password (twice):<br>
<%= hidden_field t => $t || "" %>
<%= password_field 'pass1' %><br>
<%= password_field 'pass2' %><br>
<%= submit_button 'Reset password' %>
<% end %>
